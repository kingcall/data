# phoenix 模块
   ```text
       Phoenix首先需要了解它分为Client端和server端，server端是以一个jar包的形式部署在HBASE的内部。
   server端对meta表的操作和二级索引的读写等一系列操作都是通过HBASE的ZOOKEEPER完成的。
        Phoneix是一个重客户端的引擎,重要的实现逻辑都在客户端完成，包括从sql翻译成hbase API逻辑
   和整理收集查询结果逻辑。
   ```
   - ## 二级索引
        - GLOBAL INDEX
            - GLOBAL INDEX目前为止使用场景比LOCAL INDEX更为广泛，它实质上是一张HBASE表，即把倒开索引单独存到另一张HBASE表中  
            - 由于这种设计的特性使得它更多的使用与写少多读的场景。当然由于GLOBAL INDEX是一张单独的表所以它可以使用一些主表的特性，比如可以使用加盐，指定压缩等特性。
        - LOCAL INDEX
            - LOCAL INDEX是在元数据表中多加了一个列数去存储的   
            - 由于LOCAL INDEX和元数据表是存在一张表中，故它更多的适用于写多读少的场景中，并且该特性使得主表的数据量不能过大。  
        - 总结         
           - GLOBAL INDEX和LOCAL INDEX相比LOCAL INDEX的网络开销比较小，故当索引表数据量适量的情况下LOCAL INDEX的性能更高。
           - GLOBAL INDEX和LOCAL INDEX的元数据均由Phoenix管理，Phoenix的单独管理着一套元数据信息，这些元数据信息均存在SYSTEM.CATALOG的HBASE表中
           - 目前索引创建支持同步和异步两种方式同步索引数据，同步创建索引的意思是若当前的表有数据那么创建索引的过程就是一个同步索引数据的一个过程，它会把所有的主表的数据转化成索引数据，全部同步完成以后的再将索引表的状态置成active状态
           - 异步创建索引主要是针对数据量大的场景，先执行create index创建索引表相关的元数据，再通过MR同步索引数据，该过程称之为异步创建索引。
   - ## phoenix                                             
   - 由于Phoenix基于Hbase,即使是PB级的数据量，只要建表语句合理，也能在毫秒级别返回结果  
# spark 模块
   - ### spark-phoenix
       ```text
          作为一个数据仓库，繁琐的数据处理只是其中的一环，这也正是Spark擅长的，但是还有一环，
      就是数据处理的结果以及数据详单的查询。业内普遍的做法就是将数据处理的结果回吐至传统型关系型数据，
      以及各种Nosql数据库。而Phoenix属于后者.
          回退至传统型关系数据库的数据往往是数据聚合的结果，数量级通常较小，开发人员容易理解并上手，但是缺点就是无法支撑大量的详单数据。
     ```
     ```scala
     val spark:SparkSession = SparkSession.builder()
       .appName("heihei")
       .master("local[*]")
       .getOrCreate();
  
     val df = spark.read
       .format("org.apache.phoenix.spark")
       .option("table", "TableName")
       .option("zkurl", "hbase端口")
       .load()
       ```
# 问题
   - 能否不经过sql 语句完成数据的更新 


